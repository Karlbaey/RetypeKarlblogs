---
title: 关于滑动窗口的思考🤔
published: 2025-08-12T17:19:55.211Z
description: ''
updated: ''
tags:
  - 算法
  - LeetCode
draft: true
pin: 0
toc: true
lang: ''
abbrlink: 'sliding-window-i'
---

滑动窗口是一种解决连续子区间问题的算法。它能够解决这样的一类问题：在一个数组或字符串中，找到一个子串或子数组能够满足条件。这种条件通常与最大值、最小值、唯一值或是越长 / 短越好相关。也有一些算法题目希望实现子区间能够覆盖特定部分内容，例如在 [LeetCode 76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/description/) 一题中，要求寻找能覆盖所给字符串的一个子区间，且越短越好。这些题目都有共同的特征：**维护一个先进先出（英文：FIFO，first in first out）的队列，且数据结构是线性的**。

## 定长滑动窗口

一个定长滑动窗口，可通过这样一个模板来写代码

```go
func slidingWindowI(arr []int, k int) {
    left := 0
    ans := -2147483647 // 此处是寻找最大值，如果是寻找最小值或特定字符，在条件部分以及 ans 做修改即可
    now := 0
    
    for right := 0; right < len(arr); right++ {
        now += arr[right]
        
        if right-left+1 < k {
            continue // 序列长度不足，直接重开
        }
        
        if now > ans {
            ans = now
        }
        
        now -= arr[left]
        left++
    }
    return ans // 记得返回答案
}
```

我们在此处假设输入的序列为整数列表，如果输入是字符串，那么将 `[]int` 修改为 `string` 即可，它们的本质是一样的。例如 [LeetCode 643. 子数组最大平均数 I](https://leetcode.cn/problems/maximum-average-subarray-i/description/) 的 Golang 解法可以这样写：

```go
func findMaxAverage(nums []int, k int) float64 {
	left := 0
	ans := -2147483647
	now := 0

	for right := 0; right < len(nums); right++ {
		now += nums[right]

		if right-left+1 < k {
			continue
		}

		if now > ans {
			ans = now
		}

		now -= nums[left]
		left++
	}

	return float64(ans) / float64(k)
}
```

此处需要解释几个关键变量：

- `ans` 设置为 `-2147483647` 是为了避免得到的子序列和太小以至于无法输出正确的最大值。
- `now` 用于存储当前窗口内的值

这样我们容易看出定长滑动窗口的核心思想：`进 -> 判 -> 出`，其中关键在于“判”的部分。例如，在 [LeetCode 2090. 半径为 k 的子数组平均值](https://leetcode.cn/problems/k-radius-subarray-averages/description/) 中将输出换成了一个数组，但依然是换汤不换药，我们知道只要这个窗口的长度大于等于 `2*k + 1`（体现在索引上就是 `right - left = 2*k`），就能够确认 `avgs` 中 `right-k` 处的值。`right-k` 就是半径为 k 的子数组的中心。

```go
func getAverages(nums []int, k int) []int {
	avgs := make([]int, len(nums))
	sum := 0
	left := 0

	for right := 0; right < len(nums); right++ {
		sum += nums[right]
		avgs[right] = -1

		if right >= 2*k {
			avgs[right-k] = sum / (2*k + 1)
		} else {
			continue
		}

		sum -= nums[left]
		left++
	}
	return avgs
}
```
